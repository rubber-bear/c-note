/*
指针运算
  指针+1 的动作意味着加一个sizeof

  给一个指针加1表示要让指针指向下一个变量
    int a[10];
    int *p = a;
    *(p+1) -> a[1]
  如果指针不是指向一片连续分配的空间，如数组，则这种运算没有意义

指针计算
  算数运算对指针的使用
    给指针加、减一个整数（+， +=， -， -=）
    递增、递减（++ 、--）
    两个指针相减 // 这两个地址的差 / sizeof  意思是这个区间有多少个单元

  *p++
    取出p所指的那个数据来，完事之后顺便将p移到下一个位置去
    * 的优先级虽然高， 但是没有++ 高
    常用于数组类的连续空间操作
    在某些cpu上，这可以被翻译成一条汇编指令

指针比较
  <, <=, ==, >, >=, !=
    比较它们在内存中的地址
    数组中的单元的地址肯定是线性递增的

0地址：
  当然内存中有0地址，但是0地址通常是不能随便碰的地址
  所以你的指针不应该具有0值
  因此可以用0地址来表示特殊的事情
    返回的指针式无效的
    指针没有真正初始化（先初始化为0）
  NULL 是一个预定定义的符号，表示0地址
    有的编译器不愿意你用0来表示0地址

指针的类型
  无论指向什么类型，所有的指针的大小都是一样的，因为都是地址
  但是指向不同类型的指针式不能直接相互赋值的， 这是为了避免用错指针

指针的类型转换
  void* 表示不知道指向什么东西的指针
    计算时与char*相同
  指针也可以转化类型
    int *p = &i; void*q = (void*)p;

  这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看它所指的变量

指针来做什么
  需要传入较大的数据时用做参数
  传入数组后对数组做操作
  函数返回不止一个结果
    需要用函数来修改不止一个变量
  动态申请内存


*/

#include <stdio.h>


int main() {
  char ac[] = {1, 2, 3, 4, 5, 6, 7, 8, 9,};
  char *p = &ac[0];
  // char *p1 = &ac[5];
  // printf("p =%p \n", p);
  // printf("p + 1 =%p \n", p + 1);

  // printf("p1 - p = %d\n", p1 - p);

  // // *p => ac[0]
  // // *(p+n) <-> ac[n]
  // printf("*(p+1) = %d\n", *(p + 1));

  // int ai[] = {1, 2, 3, 4, 5, 6, 7, 8, 9,};
  // int *q = ai;
  // int *q1 = &ai[5];
  // printf("q =%p \n", q);
  // printf("q1 =%p \n", q1);

  // printf("q1 - q = %d\n", q1 - q);
  int i;
  for (i = 0; i < sizeof(ac) / sizeof(ac[0]); i++) {
    printf("%d\n", ac[i]);
  }
  while (*p != -1) {
    printf("%d\n", *p++);
  }
  int ai[] = {0, 1, 2, 3, 4, 5, 6,}; 
  int *q = ai;

  return 0;
}